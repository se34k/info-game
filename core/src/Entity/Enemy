
public abstract class Enemy extends Entity{
  
  private boolean isAttackable;
  private float velocity;
  private String name;
  private int hp;
  private boolean isDead;
  int count;
  private Vector2 coordinates;
  
  public Enemy(float velocity, int hp, String name, World world, int x, int y){
    this.name = name;
    this.hp = hp;
    this.velocity = velocity;
    super(name, hp, velocity, world, x, y);
    isAttackable = true;
    isDead = false;
    count = 0;
    this.coordinates.x = x;
    this.coordinates.y = y;

  }
  
    public float getX(){
    return this.coordinates.x;   
  }
  
  public float getY(){
    return this.coordinates.Y;  
  }
  
  public float[] getPos(){
    float[] arr = {this.coordinates.x, this.coordinates.y};
    return arr;
  }
    
  public float distanceTo(Entity entity) {
    //Pythagoras is our friend
    return (float) Math.sqrt(Math.pow(entity.getX() - getX(), 2) + Math.pow(getY() - getY(), 2));
  }
  
  public boolean isAttackable(){
    return isAttackable;
  }
  
  public abstract void attack();
  
  public boolean isDead(){
    return isDead;
  }
  
  public void track(Entity entity, float Velocity, float maxVelocity){
    Body tmp = entity.getBody();
    Vector2 vector = tmp.getPosition();
    Vector2 vel = this.body.getLinearVelocity();
    if(count <= 10 && vel.x < maxVelocity && vel.y < maxVelocity){
      this.body.applyLinearImpulse(vector.sub(coordinates), coordinates, true);
      coordinates = body.getPosition();
      count++;
    }

  }
  
  public boolean isInAttackReach(float reach, Entity entity){
    if(this.distanceTo(Entity) <= reach){
        return true;
    }
    return false;
  }

}